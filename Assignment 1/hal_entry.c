#include <Library.h>

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
////////////// YOU MUST EDIT ONLY HERE ABOUT REFERENCE OF YOUR ADDITIONAL FUNCTIONS //////////////
float random();
void print_real_number(float num);
void R_FND_Display_Data(uint8_t digit, uint8_t data);
void R_FND_Reset();
void R_LED_Reset();
void analyze_signal_input();
void Billboard_print(uint8_t *string);
//////////////////////////////////////////////////////////////////////////////////////////////////
FSP_CPP_FOOTER

extern uint8_t state_mask;
extern operation_state state;

////////////// YOU MUST EDIT ONLY HERE ABOUT GLOBAL VARIABLE //////////////
volatile uint8_t stop_key = 1;
float n1 = 0.0, n2 = 0.0, mul = 0.0;

uint8_t minus = 0xFE;

uint8_t R_number[10] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xD8, 0x80, 0x90};
uint8_t number[10] = {0x81, 0xCF, 0x92, 0x86, 0xCC, 0xA4, 0xA0, 0x8D, 0x80, 0X84};
///////////////////////////////////////////////////////////////////////////

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    ////////////// YOU MUST EDIT ONLY HERE ABOUT LOCAL VARIABLE //////////////
    uint8_t string_data[4] = {0xC8, 0xB0, 0xF1, 0x98};
    uint8_t reset_data[4] = {0xFF, 0xFF, 0xFF, 0xFF};

    uint8_t student_id[18] = {0xF, 0xF, 0xF, 0xF, 2, 0, 2, 3, 1, 2, 3, 4, 5, 6, 0xF, 0xF, 0xF, 0xF};
    ///////////////////////////////////////////////////////////////////////////

    Initial_Setting();

    while(true)
    {
        ////////////// YOU MUST EDIT ONLY HERE ABOUT Assignment 1-1 //////////////
        if (state.task_mode_11 && state.task_mode_12 == 0x00 && state.task_mode_14 == 0x00)
        {
            FND_Print_Data(string_data);
            R_IOPORT_PinWrite(&g_ioport_ctrl, led_pin[0], BSP_IO_LEVEL_LOW);
        }
        else
        {
            FND_Print_Data(reset_data);
            R_IOPORT_PinWrite(&g_ioport_ctrl, led_pin[0], BSP_IO_LEVEL_HIGH);
        }
        //////////////////////////////////////////////////////////////////////////

        ////////////// YOU MUST EDIT ONLY HERE ABOUT Assignment 1-2 //////////////
        if (state.task_mode_12 && state.task_mode_14 == 0x00)
        {
            if (state.task_mode_12 == FIRST)
            {
                stop_key = 1;
                n1 = random(); n2 = random(); mul = n1 * n2;
                R_IOPORT_PinWrite(&g_ioport_ctrl, led_pin[1], BSP_IO_LEVEL_LOW);

                while(stop_key)
                {
                    switch(state.task_mode_13)
                    {
                        case 1:
                            print_real_number(n1);
                            R_IOPORT_PinWrite(&g_ioport_ctrl, led_pin[2], BSP_IO_LEVEL_LOW);
                            break;
                        case 2:
                            print_real_number(n2);
                            break;
                        case 3:
                            print_real_number(mul);
                            break;
                        case 4:
                            FND_Reset(); LED_Reset();
                            state.task_mode_12 = 0x00, state.task_mode_13 = 0x00, stop_key = 0x00;
                            break;
                        default:
                            break;
                    }
                }
            }
        }
        //////////////////////////////////////////////////////////////////////////

        ////////////// YOU MUST EDIT ONLY HERE ABOUT Assignment 1-3 //////////////
        if (state.task_mode_14 && state.task_mode_12 == 0x00)
            Billboard_print(student_id);
        //////////////////////////////////////////////////////////////////////////
    }

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

void External_Interrupt(external_irq_callback_args_t *p_args) // Interrupt Service Routine
{
    switch(p_args->channel)
    {
        case EXTERNAL_INTERRUPT_11:
            ////////////// YOU MUST EDIT ONLY HERE ABOUT Assignment 1-1 //////////////
            state.task_mode_11 ^= state_mask;
            //////////////////////////////////////////////////////////////////////////
            break;
        case EXTERNAL_INTERRUPT_12:
            ////////////// YOU MUST EDIT ONLY HERE ABOUT Assignment 1-2 //////////////
            state.task_mode_12++;
            //////////////////////////////////////////////////////////////////////////
            break;
        case EXTERNAL_INTERRUPT_13:
            ////////////// YOU MUST EDIT ONLY HERE ABOUT Assignment 1-2 //////////////
            if (state.task_mode_12 >= state_mask)
                state.task_mode_13++;
            //////////////////////////////////////////////////////////////////////////
            break;
        case EXTERNAL_INTERRUPT_14:
            ////////////// YOU MUST EDIT ONLY HERE ABOUT Assignment 1-3 //////////////
            if (state.task_mode_14 > ID_LENGTH + 2)
                state.task_mode_14 = 0;
            else
                state.task_mode_14++;
            //////////////////////////////////////////////////////////////////////////
            break;
    }
}

////////////// If you want to design the additional function, please add only here. //////////////
float random()
{
    float data = 0, cal = 1e-10f;

    while(true)
    {
        data = (float)(rand() % 199) / (float)100 + cal - (float)1.0;
        if (data > -1.0 && data < 1.0)
            break;
        else
            continue;
    }

    return data;
}
void print_real_number(float num)
{
    uint8_t idx = 0, signature = 0;
    int alpha = (int)(num * 100);

    if (alpha < 0)
        alpha *= -1, signature = 1;

    for (idx = 0; idx < DIGIT_INDEX; idx++)
    {
        switch(idx)
        {
            case 0:
                if (signature)
                    FND_Display_Data(idx, minus);
                else
                    FND_Display_Data(idx, 0xFF);
                break;
            case 1:
                FND_Display_Data(idx, number[0] & 0x7F);
                break;
            case 2:
                FND_Display_Data(idx, number[alpha / 10]);
                break;
            case 3:
                FND_Display_Data(idx, number[alpha % 10]);
        }
    }
}

void R_FND_Display_Data(uint8_t digit, uint8_t data)
{
    uint16_t high_nibble = 0, low_nibble = 0;

    R_BSP_SoftwareDelay(10, BSP_DELAY_UNITS_MICROSECONDS);
    R_FND_Reset();

    /* 7-Segment Digit Selection */
    R_PORT3->PCNTR1_b.PODR = (uint16_t)((0x0010 << (1 + digit)) & PODR_DIGIT_MASK);

    /* 7-Segment LED Pin Setting */
    high_nibble = ((uint16_t)data << PODR_INDEX_HIGH) & PODR_HIGH_MASK;
    low_nibble = ((uint16_t)data << PODR_INDEX_LOW) & PODR_LOW_MASK;
    R_PORT6->PCNTR1_b.PODR = high_nibble | low_nibble;
}

void R_FND_Reset()
{
    /* 7-Segment Initialization */
    R_PORT3->PCNTR1_b.PODR = 0x0000;
    R_PORT6->PCNTR1_b.PODR = 0x78F0;
}

void R_LED_Reset()
{
    /* LED Initialization */
    R_PORT10->PCNTR1_b.PODR = 0x0700;
    R_PORT11->PCNTR1_b.PODR = 0x0001;
}

void Billboard_print(uint8_t *string)
{
    uint8_t i = 0, idx = 0, reset = 0xFF;
    uint8_t slide_data[4] = {0x00, 0x00, 0x00, 0x00};

    for (i = 0; i < DIGIT_INDEX; i++)
    {
        idx = string[i + state.task_mode_14];
        if (idx < 0xA)
            slide_data[i] = R_number[idx];
        else
            slide_data[i] = reset;

        R_FND_Display_Data(i, slide_data[i]);
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
